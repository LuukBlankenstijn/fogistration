// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: teams.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimTeam = `-- name: ClaimTeam :one
WITH target AS (
  SELECT t.id
  FROM teams t
  JOIN contest_teams ct ON t.id = ct.team_id
  WHERE t.ip IS NULL AND ct.contest_id = $2
  FOR UPDATE SKIP LOCKED
  LIMIT 1
)
UPDATE teams t
SET ip = $1
FROM target
WHERE t.id = target.id
RETURNING t.id, t.external_id, t.name, t.display_name, t.ip, t.created_at, t.updated_at, t.hash
`

type ClaimTeamParams struct {
	Ip        pgtype.Text `hash:"exclude" json:"ip"`
	ContestID int32       `json:"contest_id"`
}

func (q *Queries) ClaimTeam(ctx context.Context, arg ClaimTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, claimTeam, arg.Ip, arg.ContestID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getAllTeams = `-- name: GetAllTeams :many
SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
`

func (q *Queries) GetAllTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.Query(ctx, getAllTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.DisplayName,
			&i.Ip,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamByExternalId = `-- name: GetTeamByExternalId :one
SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
WHERE external_id = $1
`

func (q *Queries) GetTeamByExternalId(ctx context.Context, externalID string) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByExternalId, externalID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamById = `-- name: GetTeamById :one
SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
WHERE id = $1
`

func (q *Queries) GetTeamById(ctx context.Context, id int32) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamById, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamByIp = `-- name: GetTeamByIp :one
SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
WHERE ip = $1
`

func (q *Queries) GetTeamByIp(ctx context.Context, ip pgtype.Text) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByIp, ip)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamHashes = `-- name: GetTeamHashes :many
SELECT id, hash FROM teams
ORDER BY id
`

type GetTeamHashesRow struct {
	ID   int32  `json:"id"`
	Hash string `hash:"exclude" json:"hash"`
}

func (q *Queries) GetTeamHashes(ctx context.Context) ([]GetTeamHashesRow, error) {
	rows, err := q.db.Query(ctx, getTeamHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamHashesRow
	for rows.Next() {
		var i GetTeamHashesRow
		if err := rows.Scan(&i.ID, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateIp = `-- name: UpdateIp :one
UPDATE teams
SET ip = $2
WHERE external_id= $1
RETURNING id, external_id, name, display_name, ip, created_at, updated_at, hash
`

type UpdateIpParams struct {
	ExternalID string      `json:"external_id"`
	Ip         pgtype.Text `hash:"exclude" json:"ip"`
}

func (q *Queries) UpdateIp(ctx context.Context, arg UpdateIpParams) (Team, error) {
	row := q.db.QueryRow(ctx, updateIp, arg.ExternalID, arg.Ip)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const upsertTeam = `-- name: UpsertTeam :exec
INSERT INTO teams (
    id,
    external_id,
    name,
    display_name,
    ip,
    created_at,
    updated_at,
    hash
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), $6
)
ON CONFLICT (id)
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    name = EXCLUDED.name,
    display_name = EXCLUDED.display_name,
    ip = EXCLUDED.ip,
    updated_at = NOW(),
    hash = EXCLUDED.hash
`

type UpsertTeamParams struct {
	ID          int32       `json:"id"`
	ExternalID  string      `json:"external_id"`
	Name        string      `json:"name"`
	DisplayName pgtype.Text `json:"display_name"`
	Ip          pgtype.Text `hash:"exclude" json:"ip"`
	Hash        string      `hash:"exclude" json:"hash"`
}

func (q *Queries) UpsertTeam(ctx context.Context, arg UpsertTeamParams) error {
	_, err := q.db.Exec(ctx, upsertTeam,
		arg.ID,
		arg.ExternalID,
		arg.Name,
		arg.DisplayName,
		arg.Ip,
		arg.Hash,
	)
	return err
}
