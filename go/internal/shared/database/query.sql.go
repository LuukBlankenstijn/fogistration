// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimTeam = `-- name: ClaimTeam :one
WITH target AS (
  SELECT t.id
  FROM teams t
  JOIN contest_teams ct ON t.id = ct.team_id
  WHERE t.ip IS NULL AND ct.contest_id = $2
  FOR UPDATE SKIP LOCKED
  LIMIT 1
)
UPDATE teams t
SET ip = $1
FROM target
WHERE t.id = target.id
RETURNING t.id, t.external_id, t.name, t.display_name, t.ip, t.created_at, t.updated_at, t.hash
`

type ClaimTeamParams struct {
	Ip        pgtype.Text
	ContestID int32
}

func (q *Queries) ClaimTeam(ctx context.Context, arg ClaimTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, claimTeam, arg.Ip, arg.ContestID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM app_user
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuthSecret = `-- name: CreateAuthSecret :one
INSERT INTO auth_secret (user_id, password_hash, salt)
VALUES ($1, $2, $3)
RETURNING user_id, password_hash, salt, created_at, updated_at
`

type CreateAuthSecretParams struct {
	UserID       int64
	PasswordHash string
	Salt         string
}

func (q *Queries) CreateAuthSecret(ctx context.Context, arg CreateAuthSecretParams) (AuthSecret, error) {
	row := q.db.QueryRow(ctx, createAuthSecret, arg.UserID, arg.PasswordHash, arg.Salt)
	var i AuthSecret
	err := row.Scan(
		&i.UserID,
		&i.PasswordHash,
		&i.Salt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createLocalUser = `-- name: CreateLocalUser :one
INSERT INTO app_user (username, email, role)
VALUES ($1, $2, $3)
RETURNING id, username, email, role, external_id, created_at, updated_at, last_login_at
`

type CreateLocalUserParams struct {
	Username string
	Email    string
	Role     string
}

func (q *Queries) CreateLocalUser(ctx context.Context, arg CreateLocalUserParams) (AppUser, error) {
	row := q.db.QueryRow(ctx, createLocalUser, arg.Username, arg.Email, arg.Role)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.ExternalID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const deleteAllContestTeams = `-- name: DeleteAllContestTeams :exec


DELETE FROM contest_teams WHERE contest_id = $1
`

// CONTEST TEAMS
func (q *Queries) DeleteAllContestTeams(ctx context.Context, contestID int32) error {
	_, err := q.db.Exec(ctx, deleteAllContestTeams, contestID)
	return err
}

const deleteAuthSecret = `-- name: DeleteAuthSecret :exec
DELETE FROM auth_secret
WHERE user_id = $1
`

func (q *Queries) DeleteAuthSecret(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteAuthSecret, userID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM app_user
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const dequeueCommand = `-- name: DequeueCommand :one
DELETE FROM message_queue 
WHERE id = (
    SELECT id FROM message_queue 
    ORDER BY created_at ASC 
    FOR UPDATE SKIP LOCKED 
    LIMIT 1
)
RETURNING id, command_type, payload, created_at
`

func (q *Queries) DequeueCommand(ctx context.Context) (MessageQueue, error) {
	row := q.db.QueryRow(ctx, dequeueCommand)
	var i MessageQueue
	err := row.Scan(
		&i.ID,
		&i.CommandType,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const enqueueCommand = `-- name: EnqueueCommand :exec


INSERT INTO message_queue (command_type, payload)
VALUES ($1, $2)
`

type EnqueueCommandParams struct {
	CommandType string
	Payload     []byte
}

// COMMANDS
func (q *Queries) EnqueueCommand(ctx context.Context, arg EnqueueCommandParams) error {
	_, err := q.db.Exec(ctx, enqueueCommand, arg.CommandType, arg.Payload)
	return err
}

const getAllClients = `-- name: GetAllClients :many
SELECT id, ip, last_seen, created_at FROM clients
`

func (q *Queries) GetAllClients(ctx context.Context) ([]Client, error) {
	rows, err := q.db.Query(ctx, getAllClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.Ip,
			&i.LastSeen,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTeams = `-- name: GetAllTeams :many
SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
`

func (q *Queries) GetAllTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.Query(ctx, getAllTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.DisplayName,
			&i.Ip,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthSecret = `-- name: GetAuthSecret :one
SELECT user_id, password_hash, salt, created_at, updated_at
FROM auth_secret
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) GetAuthSecret(ctx context.Context, userID int64) (AuthSecret, error) {
	row := q.db.QueryRow(ctx, getAuthSecret, userID)
	var i AuthSecret
	err := row.Scan(
		&i.UserID,
		&i.PasswordHash,
		&i.Salt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientById = `-- name: GetClientById :one


SELECT id, ip, last_seen, created_at FROM clients
WHERE id = $1
`

// CLIENTS
func (q *Queries) GetClientById(ctx context.Context, id int32) (Client, error) {
	row := q.db.QueryRow(ctx, getClientById, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.LastSeen,
		&i.CreatedAt,
	)
	return i, err
}

const getContestHashes = `-- name: GetContestHashes :many
SELECT id, hash FROM contests
ORDER BY id
`

type GetContestHashesRow struct {
	ID   int32
	Hash string `hash:"exclude"`
}

func (q *Queries) GetContestHashes(ctx context.Context) ([]GetContestHashesRow, error) {
	rows, err := q.db.Query(ctx, getContestHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContestHashesRow
	for rows.Next() {
		var i GetContestHashesRow
		if err := rows.Scan(&i.ID, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextOrActiveContest = `-- name: GetNextOrActiveContest :one
SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
WHERE end_time > NOW()
ORDER BY start_time ASC
LIMIT 1
`

func (q *Queries) GetNextOrActiveContest(ctx context.Context) (Contest, error) {
	row := q.db.QueryRow(ctx, getNextOrActiveContest)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.FormalName,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamByExternalId = `-- name: GetTeamByExternalId :one
SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
WHERE external_id = $1
`

func (q *Queries) GetTeamByExternalId(ctx context.Context, externalID string) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByExternalId, externalID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamById = `-- name: GetTeamById :one


SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
WHERE id = $1
`

// TEAMS:
func (q *Queries) GetTeamById(ctx context.Context, id int32) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamById, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamByIp = `-- name: GetTeamByIp :one
SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
WHERE ip = $1
`

func (q *Queries) GetTeamByIp(ctx context.Context, ip pgtype.Text) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByIp, ip)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamHashes = `-- name: GetTeamHashes :many
SELECT id, hash FROM teams
ORDER BY id
`

type GetTeamHashesRow struct {
	ID   int32
	Hash string `hash:"exclude"`
}

func (q *Queries) GetTeamHashes(ctx context.Context) ([]GetTeamHashesRow, error) {
	rows, err := q.db.Query(ctx, getTeamHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamHashesRow
	for rows.Next() {
		var i GetTeamHashesRow
		if err := rows.Scan(&i.ID, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, role, external_id, created_at, updated_at, last_login_at FROM app_user
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (AppUser, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.ExternalID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getUserByUsernameCI = `-- name: GetUserByUsernameCI :one
SELECT id, username, email, role, external_id, created_at, updated_at, last_login_at FROM app_user
WHERE lower(username) = lower($1)
LIMIT 1
`

func (q *Queries) GetUserByUsernameCI(ctx context.Context, lower string) (AppUser, error) {
	row := q.db.QueryRow(ctx, getUserByUsernameCI, lower)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.ExternalID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

type InsertContestTeamsParams struct {
	ContestID int32
	TeamID    int32
}

const listContests = `-- name: ListContests :many


SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
ORDER BY id
`

// CONTESTS
func (q *Queries) ListContests(ctx context.Context) ([]Contest, error) {
	rows, err := q.db.Query(ctx, listContests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contest
	for rows.Next() {
		var i Contest
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.FormalName,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, role, external_id, created_at, updated_at, last_login_at FROM app_user
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]AppUser, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUser
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Role,
			&i.ExternalID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const touchLastLogin = `-- name: TouchLastLogin :one
UPDATE app_user
SET last_login_at = now()
WHERE id = $1
RETURNING id, username, email, role, external_id, created_at, updated_at, last_login_at
`

func (q *Queries) TouchLastLogin(ctx context.Context, id int64) (AppUser, error) {
	row := q.db.QueryRow(ctx, touchLastLogin, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.ExternalID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const updateAuthSecret = `-- name: UpdateAuthSecret :one
UPDATE auth_secret
SET
  password_hash = $2,
  salt          = $3,
  updated_at    = now()
WHERE user_id = $1
RETURNING user_id, password_hash, salt, created_at, updated_at
`

type UpdateAuthSecretParams struct {
	UserID       int64
	PasswordHash string
	Salt         string
}

func (q *Queries) UpdateAuthSecret(ctx context.Context, arg UpdateAuthSecretParams) (AuthSecret, error) {
	row := q.db.QueryRow(ctx, updateAuthSecret, arg.UserID, arg.PasswordHash, arg.Salt)
	var i AuthSecret
	err := row.Scan(
		&i.UserID,
		&i.PasswordHash,
		&i.Salt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateClientLastSeen = `-- name: UpdateClientLastSeen :exec
UPDATE clients
SET last_seen = NOW()
WHERE ip = $1
`

func (q *Queries) UpdateClientLastSeen(ctx context.Context, ip string) error {
	_, err := q.db.Exec(ctx, updateClientLastSeen, ip)
	return err
}

const updateIp = `-- name: UpdateIp :one
UPDATE teams
SET ip = $2
WHERE external_id= $1
RETURNING id, external_id, name, display_name, ip, created_at, updated_at, hash
`

type UpdateIpParams struct {
	ExternalID string
	Ip         pgtype.Text
}

func (q *Queries) UpdateIp(ctx context.Context, arg UpdateIpParams) (Team, error) {
	row := q.db.QueryRow(ctx, updateIp, arg.ExternalID, arg.Ip)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE app_user
SET
  username = COALESCE($1, username),
  email    = COALESCE($2, email),
  role     = COALESCE($3, role)
WHERE id = $4
RETURNING id, username, email, role, external_id, created_at, updated_at, last_login_at
`

type UpdateUserProfileParams struct {
	Username pgtype.Text
	Email    pgtype.Text
	Role     pgtype.Text
	ID       int64
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (AppUser, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.Username,
		arg.Email,
		arg.Role,
		arg.ID,
	)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Role,
		&i.ExternalID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const upsertAuthSecret = `-- name: UpsertAuthSecret :one
INSERT INTO auth_secret (user_id, password_hash, salt)
VALUES ($1, $2, $3)
ON CONFLICT (user_id) DO UPDATE
SET
  password_hash = EXCLUDED.password_hash,
  salt          = EXCLUDED.salt,
  updated_at    = now()
RETURNING user_id, password_hash, salt, created_at, updated_at
`

type UpsertAuthSecretParams struct {
	UserID       int64
	PasswordHash string
	Salt         string
}

func (q *Queries) UpsertAuthSecret(ctx context.Context, arg UpsertAuthSecretParams) (AuthSecret, error) {
	row := q.db.QueryRow(ctx, upsertAuthSecret, arg.UserID, arg.PasswordHash, arg.Salt)
	var i AuthSecret
	err := row.Scan(
		&i.UserID,
		&i.PasswordHash,
		&i.Salt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertClient = `-- name: UpsertClient :one
INSERT INTO clients (
    ip
) VALUES (
    $1
)
ON CONFLICT (ip)
DO UPDATE SET
    last_seen = NOW()
RETURNING id, ip, last_seen, created_at
`

func (q *Queries) UpsertClient(ctx context.Context, ip string) (Client, error) {
	row := q.db.QueryRow(ctx, upsertClient, ip)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.LastSeen,
		&i.CreatedAt,
	)
	return i, err
}

const upsertContest = `-- name: UpsertContest :exec
INSERT INTO contests (
    id,
    external_id,
    formal_name,
    start_time,
    end_time,
    created_at,
    updated_at,
    hash
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), $6
)
ON CONFLICT (id) 
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    formal_name = EXCLUDED.formal_name,
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    updated_at = NOW(),
    hash = EXCLUDED.hash
`

type UpsertContestParams struct {
	ID         int32
	ExternalID string
	FormalName string
	StartTime  pgtype.Timestamp
	EndTime    pgtype.Timestamp
	Hash       string `hash:"exclude"`
}

func (q *Queries) UpsertContest(ctx context.Context, arg UpsertContestParams) error {
	_, err := q.db.Exec(ctx, upsertContest,
		arg.ID,
		arg.ExternalID,
		arg.FormalName,
		arg.StartTime,
		arg.EndTime,
		arg.Hash,
	)
	return err
}

const upsertTeam = `-- name: UpsertTeam :exec
INSERT INTO teams (
    id,
    external_id,
    name,
    display_name,
    ip,
    created_at,
    updated_at,
    hash
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), $6
)
ON CONFLICT (id)
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    name = EXCLUDED.name,
    display_name = EXCLUDED.display_name,
    ip = EXCLUDED.ip,
    updated_at = NOW(),
    hash = EXCLUDED.hash
`

type UpsertTeamParams struct {
	ID          int32
	ExternalID  string
	Name        string
	DisplayName pgtype.Text
	Ip          pgtype.Text
	Hash        string `hash:"exclude"`
}

func (q *Queries) UpsertTeam(ctx context.Context, arg UpsertTeamParams) error {
	_, err := q.db.Exec(ctx, upsertTeam,
		arg.ID,
		arg.ExternalID,
		arg.Name,
		arg.DisplayName,
		arg.Ip,
		arg.Hash,
	)
	return err
}
