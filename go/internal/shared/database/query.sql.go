// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimTeam = `-- name: ClaimTeam :one
WITH target AS (
  SELECT t.id
  FROM teams t
  JOIN contest_teams ct ON t.id = ct.team_id
  WHERE t.ip IS NULL AND ct.contest_id = $2
  FOR UPDATE SKIP LOCKED
  LIMIT 1
)
UPDATE teams t
SET ip = $1
FROM target
WHERE t.id = target.id
RETURNING t.id, t.external_id, t.name, t.display_name, t.ip, t.created_at, t.updated_at, t.hash
`

type ClaimTeamParams struct {
	Ip        pgtype.Text
	ContestID int32
}

func (q *Queries) ClaimTeam(ctx context.Context, arg ClaimTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, claimTeam, arg.Ip, arg.ContestID)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const deleteAllContestTeams = `-- name: DeleteAllContestTeams :exec


DELETE FROM contest_teams WHERE contest_id = $1
`

// CONTEST TEAMS
func (q *Queries) DeleteAllContestTeams(ctx context.Context, contestID int32) error {
	_, err := q.db.Exec(ctx, deleteAllContestTeams, contestID)
	return err
}

const dequeueCommand = `-- name: DequeueCommand :one
DELETE FROM message_queue 
WHERE id = (
    SELECT id FROM message_queue 
    ORDER BY created_at ASC 
    FOR UPDATE SKIP LOCKED 
    LIMIT 1
)
RETURNING id, command_type, payload, created_at
`

func (q *Queries) DequeueCommand(ctx context.Context) (MessageQueue, error) {
	row := q.db.QueryRow(ctx, dequeueCommand)
	var i MessageQueue
	err := row.Scan(
		&i.ID,
		&i.CommandType,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const enqueueCommand = `-- name: EnqueueCommand :exec


INSERT INTO message_queue (command_type, payload)
VALUES ($1, $2)
`

type EnqueueCommandParams struct {
	CommandType string
	Payload     []byte
}

// COMMANDS
func (q *Queries) EnqueueCommand(ctx context.Context, arg EnqueueCommandParams) error {
	_, err := q.db.Exec(ctx, enqueueCommand, arg.CommandType, arg.Payload)
	return err
}

const getContestHashes = `-- name: GetContestHashes :many
SELECT id, hash FROM contests
ORDER BY id
`

type GetContestHashesRow struct {
	ID   int32
	Hash string `hash:"exclude"`
}

func (q *Queries) GetContestHashes(ctx context.Context) ([]GetContestHashesRow, error) {
	rows, err := q.db.Query(ctx, getContestHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContestHashesRow
	for rows.Next() {
		var i GetContestHashesRow
		if err := rows.Scan(&i.ID, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextOrActiveContest = `-- name: GetNextOrActiveContest :one
SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
WHERE end_time > NOW()
ORDER BY start_time ASC
LIMIT 1
`

func (q *Queries) GetNextOrActiveContest(ctx context.Context) (Contest, error) {
	row := q.db.QueryRow(ctx, getNextOrActiveContest)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.FormalName,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamById = `-- name: GetTeamById :one


SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
WHERE id = $1
`

// TEAMS:
func (q *Queries) GetTeamById(ctx context.Context, id int32) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamById, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamByIp = `-- name: GetTeamByIp :one
SELECT id, external_id, name, display_name, ip, created_at, updated_at, hash FROM teams
WHERE ip = $1
`

func (q *Queries) GetTeamByIp(ctx context.Context, ip pgtype.Text) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamByIp, ip)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.DisplayName,
		&i.Ip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getTeamHashes = `-- name: GetTeamHashes :many
SELECT id, hash FROM teams
ORDER BY id
`

type GetTeamHashesRow struct {
	ID   int32
	Hash string `hash:"exclude"`
}

func (q *Queries) GetTeamHashes(ctx context.Context) ([]GetTeamHashesRow, error) {
	rows, err := q.db.Query(ctx, getTeamHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamHashesRow
	for rows.Next() {
		var i GetTeamHashesRow
		if err := rows.Scan(&i.ID, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertContestTeamsParams struct {
	ContestID int32
	TeamID    int32
}

const listContests = `-- name: ListContests :many


SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
ORDER BY id
`

// CONTESTS
func (q *Queries) ListContests(ctx context.Context) ([]Contest, error) {
	rows, err := q.db.Query(ctx, listContests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contest
	for rows.Next() {
		var i Contest
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.FormalName,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClientLastSeen = `-- name: UpdateClientLastSeen :exec


UPDATE clients
SET last_seen = NOW()
WHERE ip = $1
`

// CLIENTS
func (q *Queries) UpdateClientLastSeen(ctx context.Context, ip string) error {
	_, err := q.db.Exec(ctx, updateClientLastSeen, ip)
	return err
}

const updateIp = `-- name: UpdateIp :exec
UPDATE teams
SET ip = $2
WHERE id = $1
`

type UpdateIpParams struct {
	ID int32
	Ip pgtype.Text
}

func (q *Queries) UpdateIp(ctx context.Context, arg UpdateIpParams) error {
	_, err := q.db.Exec(ctx, updateIp, arg.ID, arg.Ip)
	return err
}

const upsertClient = `-- name: UpsertClient :one
INSERT INTO clients (
    ip
) VALUES (
    $1
)
ON CONFLICT (ip)
DO UPDATE SET
    last_seen = NOW()
RETURNING id, ip, last_seen, created_at
`

func (q *Queries) UpsertClient(ctx context.Context, ip string) (Client, error) {
	row := q.db.QueryRow(ctx, upsertClient, ip)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.LastSeen,
		&i.CreatedAt,
	)
	return i, err
}

const upsertContest = `-- name: UpsertContest :exec
INSERT INTO contests (
    id,
    external_id,
    formal_name,
    start_time,
    end_time,
    created_at,
    updated_at,
    hash
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), $6
)
ON CONFLICT (id) 
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    formal_name = EXCLUDED.formal_name,
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    updated_at = NOW(),
    hash = EXCLUDED.hash
`

type UpsertContestParams struct {
	ID         int32
	ExternalID string
	FormalName string
	StartTime  pgtype.Timestamp
	EndTime    pgtype.Timestamp
	Hash       string `hash:"exclude"`
}

func (q *Queries) UpsertContest(ctx context.Context, arg UpsertContestParams) error {
	_, err := q.db.Exec(ctx, upsertContest,
		arg.ID,
		arg.ExternalID,
		arg.FormalName,
		arg.StartTime,
		arg.EndTime,
		arg.Hash,
	)
	return err
}

const upsertTeam = `-- name: UpsertTeam :exec
INSERT INTO teams (
    id,
    external_id,
    name,
    display_name,
    ip,
    created_at,
    updated_at,
    hash
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), $6
)
ON CONFLICT (id)
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    name = EXCLUDED.name,
    display_name = EXCLUDED.display_name,
    ip = EXCLUDED.ip,
    updated_at = NOW(),
    hash = EXCLUDED.hash
`

type UpsertTeamParams struct {
	ID          int32
	ExternalID  string
	Name        string
	DisplayName pgtype.Text
	Ip          pgtype.Text
	Hash        string `hash:"exclude"`
}

func (q *Queries) UpsertTeam(ctx context.Context, arg UpsertTeamParams) error {
	_, err := q.db.Exec(ctx, upsertTeam,
		arg.ID,
		arg.ExternalID,
		arg.Name,
		arg.DisplayName,
		arg.Ip,
		arg.Hash,
	)
	return err
}
