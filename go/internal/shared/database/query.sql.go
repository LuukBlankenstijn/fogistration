// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAllContestTeams = `-- name: DeleteAllContestTeams :exec
DELETE FROM contest_teams WHERE contest_id = $1
`

func (q *Queries) DeleteAllContestTeams(ctx context.Context, contestID int32) error {
	_, err := q.db.Exec(ctx, deleteAllContestTeams, contestID)
	return err
}

const getContestHashes = `-- name: GetContestHashes :many
SELECT id, hash FROM contests
ORDER BY id
`

type GetContestHashesRow struct {
	ID   int32
	Hash string `hash:"exclude"`
}

func (q *Queries) GetContestHashes(ctx context.Context) ([]GetContestHashesRow, error) {
	rows, err := q.db.Query(ctx, getContestHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContestHashesRow
	for rows.Next() {
		var i GetContestHashesRow
		if err := rows.Scan(&i.ID, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextOrActiveContest = `-- name: GetNextOrActiveContest :many
SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
WHERE end_time > NOW()
ORDER BY start_time ASC
LIMIT 1
`

func (q *Queries) GetNextOrActiveContest(ctx context.Context) ([]Contest, error) {
	rows, err := q.db.Query(ctx, getNextOrActiveContest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contest
	for rows.Next() {
		var i Contest
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.FormalName,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamHashes = `-- name: GetTeamHashes :many
SELECT id, hash FROM teams
ORDER BY id
`

type GetTeamHashesRow struct {
	ID   int32
	Hash string `hash:"exclude"`
}

func (q *Queries) GetTeamHashes(ctx context.Context) ([]GetTeamHashesRow, error) {
	rows, err := q.db.Query(ctx, getTeamHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamHashesRow
	for rows.Next() {
		var i GetTeamHashesRow
		if err := rows.Scan(&i.ID, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertContestTeamsParams struct {
	ContestID int32
	TeamID    int32
}

const listContests = `-- name: ListContests :many
SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
ORDER BY id
`

func (q *Queries) ListContests(ctx context.Context) ([]Contest, error) {
	rows, err := q.db.Query(ctx, listContests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contest
	for rows.Next() {
		var i Contest
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.FormalName,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContest = `-- name: UpsertContest :exec
INSERT INTO contests (
    id,
    external_id,
    formal_name,
    start_time,
    end_time,
    created_at,
    updated_at,
    hash
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), $6
)
ON CONFLICT (id) 
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    formal_name = EXCLUDED.formal_name,
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    updated_at = NOW(),
    hash = EXCLUDED.hash
`

type UpsertContestParams struct {
	ID         int32
	ExternalID string
	FormalName string
	StartTime  pgtype.Timestamp
	EndTime    pgtype.Timestamp
	Hash       string `hash:"exclude"`
}

func (q *Queries) UpsertContest(ctx context.Context, arg UpsertContestParams) error {
	_, err := q.db.Exec(ctx, upsertContest,
		arg.ID,
		arg.ExternalID,
		arg.FormalName,
		arg.StartTime,
		arg.EndTime,
		arg.Hash,
	)
	return err
}

const upsertTeam = `-- name: UpsertTeam :exec
INSERT INTO teams (
    id,
    external_id,
    name,
    display_name,
    ip,
    created_at,
    updated_at,
    hash
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), $6
)
ON CONFLICT (id) 
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    name = EXCLUDED.name,
    display_name = EXCLUDED.display_name,
    ip = EXCLUDED.ip,
    updated_at = NOW(),
    hash = EXCLUDED.hash
`

type UpsertTeamParams struct {
	ID          int32
	ExternalID  string
	Name        string
	DisplayName pgtype.Text
	Ip          pgtype.Text
	Hash        string `hash:"exclude"`
}

func (q *Queries) UpsertTeam(ctx context.Context, arg UpsertTeamParams) error {
	_, err := q.db.Exec(ctx, upsertTeam,
		arg.ID,
		arg.ExternalID,
		arg.Name,
		arg.DisplayName,
		arg.Ip,
		arg.Hash,
	)
	return err
}
