// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: contests.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getContestByExternalId = `-- name: GetContestByExternalId :one
SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
WHERE external_id = $1
`

func (q *Queries) GetContestByExternalId(ctx context.Context, externalID string) (Contest, error) {
	row := q.db.QueryRow(ctx, getContestByExternalId, externalID)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.FormalName,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const getContestHashes = `-- name: GetContestHashes :many
SELECT id, hash FROM contests
ORDER BY id
`

type GetContestHashesRow struct {
	ID   int32  `json:"id"`
	Hash string `hash:"exclude" json:"hash"`
}

func (q *Queries) GetContestHashes(ctx context.Context) ([]GetContestHashesRow, error) {
	rows, err := q.db.Query(ctx, getContestHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContestHashesRow
	for rows.Next() {
		var i GetContestHashesRow
		if err := rows.Scan(&i.ID, &i.Hash); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextOrActiveContest = `-- name: GetNextOrActiveContest :one
SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
WHERE end_time > NOW()
ORDER BY start_time ASC
LIMIT 1
`

func (q *Queries) GetNextOrActiveContest(ctx context.Context) (Contest, error) {
	row := q.db.QueryRow(ctx, getNextOrActiveContest)
	var i Contest
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.FormalName,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Hash,
	)
	return i, err
}

const listContests = `-- name: ListContests :many
SELECT id, external_id, formal_name, start_time, end_time, created_at, updated_at, hash FROM contests
ORDER BY id
`

func (q *Queries) ListContests(ctx context.Context) ([]Contest, error) {
	rows, err := q.db.Query(ctx, listContests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contest
	for rows.Next() {
		var i Contest
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.FormalName,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContest = `-- name: UpsertContest :exec
INSERT INTO contests (
    id,
    external_id,
    formal_name,
    start_time,
    end_time,
    created_at,
    updated_at,
    hash
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), $6
)
ON CONFLICT (id) 
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    formal_name = EXCLUDED.formal_name,
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    updated_at = NOW(),
    hash = EXCLUDED.hash
`

type UpsertContestParams struct {
	ID         int32            `json:"id"`
	ExternalID string           `json:"external_id"`
	FormalName string           `json:"formal_name"`
	StartTime  pgtype.Timestamp `json:"start_time"`
	EndTime    pgtype.Timestamp `json:"end_time"`
	Hash       string           `hash:"exclude" json:"hash"`
}

func (q *Queries) UpsertContest(ctx context.Context, arg UpsertContestParams) error {
	_, err := q.db.Exec(ctx, upsertContest,
		arg.ID,
		arg.ExternalID,
		arg.FormalName,
		arg.StartTime,
		arg.EndTime,
		arg.Hash,
	)
	return err
}
