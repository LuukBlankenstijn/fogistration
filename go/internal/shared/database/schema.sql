-- Generated by cmd/schema-builder/main.go DO NOT EDIT MANUALLY
-- Migration: 001_domjudge.sql
-- Write your migrate up statements here
--
---- Contests table
CREATE TABLE IF NOT EXISTS contests (
    id INTEGER PRIMARY KEY,
    external_id VARCHAR NOT NULL,
    formal_name VARCHAR NOT NULL,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    hash VARCHAR NOT NULL
);

-- Teams table  
CREATE TABLE IF NOT EXISTS teams (
    id INTEGER PRIMARY KEY,
    external_id VARCHAR NOT NULL,
    name VARCHAR NOT NULL,
    display_name VARCHAR,
    ip VARCHAR,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    hash VARCHAR NOT NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS unique_ip_not_null ON teams (ip) WHERE ip IS NOT NULL;

-- Users table
CREATE TABLE IF NOT EXISTS users (
    id VARCHAR PRIMARY KEY,
    name VARCHAR NOT NULL,
    team_id INTEGER REFERENCES teams (id),
    ip VARCHAR,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    hash VARCHAR NOT NULL
);

-- Contest-Team relationship (many-to-many)
CREATE TABLE IF NOT EXISTS contest_teams (
    contest_id INTEGER REFERENCES contests (id) ON DELETE CASCADE,
    team_id INTEGER REFERENCES teams (id) ON DELETE CASCADE,
    PRIMARY KEY (contest_id, team_id)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_team_id ON users (team_id);
CREATE INDEX IF NOT EXISTS idx_contest_teams_contest_id ON contest_teams (contest_id);
CREATE INDEX IF NOT EXISTS idx_contest_teams_team_id ON contest_teams (team_id);

-- Migration: 002_commands.sql
-- Write your migrate up statements here
CREATE TABLE message_queue (
    id SERIAL PRIMARY KEY,
    command_type VARCHAR NOT NULL,
    payload JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Trigger for notifications
CREATE OR REPLACE FUNCTION notify_new_command()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify('new_command', '');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_notify_new_command
    AFTER INSERT ON message_queue
    FOR EACH ROW
    EXECUTE FUNCTION notify_new_command();

-- Migration: 003_client.sql
-- Write your migrate up statements here
CREATE TABLE clients (
    id SERIAL PRIMARY KEY,
    ip VARCHAR NOT NULL UNIQUE,
    last_seen TIMESTAMP NOT NULL DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Migration: 004_team_ip_trigger.sql
-- Write your migrate up statements here

CREATE OR REPLACE FUNCTION notify_ip_change() RETURNS trigger AS $$
DECLARE
    data JSONB;
    notify_type TEXT := 'change_ip';
BEGIN
    IF NEW.ip IS DISTINCT FROM OLD.ip THEN
        data := jsonb_build_object(
            'id', NEW.id,
            'ip', to_jsonb(NEW.ip),
            'ip_old', to_jsonb(OLD.ip)
        );

        -- Send NOTIFY with the same type
        PERFORM pg_notify(notify_type, data::text);

        -- Insert into command_queue with the same type
        INSERT INTO message_queue (command_type, payload)
        VALUES (notify_type, data);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_ip_change
AFTER UPDATE ON teams
FOR EACH ROW
WHEN (OLD.ip IS DISTINCT FROM NEW.ip)
EXECUTE FUNCTION notify_ip_change();

-- Migration: 005_webuser.sql
-- Write your migrate up statements here
CREATE TABLE app_user (
  id           BIGSERIAL PRIMARY KEY,
  username     TEXT NOT NULL,
  email        TEXT NOT NULL,
  role         TEXT NOT NULL DEFAULT 'user',
  external_id  TEXT,                        -- Keycloak sub (NULL for local)

  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_login_at TIMESTAMPTZ,

  -- ensure updated_at touches
  CONSTRAINT app_user_updated_at_chk CHECK (updated_at IS NOT NULL)
);

-- case-insensitive unique username
CREATE UNIQUE INDEX ux_user_username_ci ON app_user (lower(username));

-- external_id unique when present
CREATE UNIQUE INDEX ux_user_external_id ON app_user (external_id) WHERE external_id IS NOT NULL;

-- secrets for local users
CREATE TABLE auth_secret (
  user_id       BIGINT PRIMARY KEY REFERENCES app_user(id) ON DELETE CASCADE,
  password_hash TEXT NOT NULL,
  salt          TEXT NOT NULL,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- touch helper
CREATE OR REPLACE FUNCTION tg_touch_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN NEW.updated_at := now(); RETURN NEW; END $$;

CREATE TRIGGER app_user_touch
BEFORE UPDATE ON app_user
FOR EACH ROW EXECUTE FUNCTION tg_touch_updated_at();

CREATE TRIGGER auth_secret_touch
BEFORE UPDATE ON auth_secret
FOR EACH ROW EXECUTE FUNCTION tg_touch_updated_at();

